{"meta":{"title":"Zakeeee","subtitle":null,"description":null,"author":"Jin","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2018-05-20T09:37:10.000Z","updated":"2020-08-23T10:40:44.282Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-20T09:37:01.000Z","updated":"2020-08-23T10:40:44.286Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python中的一些概念","slug":"python中的一些概念","date":"2018-01-16T12:54:06.000Z","updated":"2020-08-23T10:40:44.279Z","comments":true,"path":"2018/01/16/python中的一些概念/","link":"","permalink":"http://yoursite.com/2018/01/16/python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/","excerpt":"Python中的一些概念 这里只简单概述一些python中的概念，更多内容请自行通过书籍资料学习。","text":"Python中的一些概念 这里只简单概述一些python中的概念，更多内容请自行通过书籍资料学习。 闭包 Wiki 在计算机科学中，闭包，又称词法闭包或函数闭包，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 在如下例子中，func构成一个闭包，其中的自由变量n和dictionary与func一同存在。func函数返回了add_value这个函数，add_value这个函数又使用了父函数func中的变量。原本函数中的局部变量仅仅在函数的执行期间是可用的，我们会认为n和dictionary在执行完f1=func('1')这段代码之后应该就不可用了，但是事实上它们会同func一同存在，这种现象就是闭包。 123456789101112131415161718192021def func(name): # func构成一个闭包 n = name # n是自由变量 dictionary = &#123;&#125; # dictionary是自由变量 def add_value(k, v): dictionary[k] = v print(&#x27;&#123;&#125;: &#123;&#125;&#x27;.format(n, dictionary)) return add_valuef1 = func(&#x27;1&#x27;)f2 = func(&#x27;2&#x27;)f1(&#x27;name&#x27;, &#x27;Alice&#x27;)f1(&#x27;age&#x27;, 18)f2(&#x27;name&#x27;, &#x27;Bob&#x27;)# Output# 1: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;&#125;# 1: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 18&#125;# 2: &#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125; 装饰器 装饰器与闭包十分相似，装饰器能够在不改变原有函数的情况下给函数添加新的功能。它的实质其实是接受了函数作为参数，经过添加一些功能（装饰），然后返回了一个被装饰后的函数。 装饰器的用途很多，不光能动态增加函数的功能，还能用来存储信息，这点与闭包是相似的，可以在装饰器中存储自由变量。 下面的例子中，装饰器elapsed给fib添加了计算耗时的功能，这个时候的fib已经不是原本的fib了，而是被elapsed返回的wrapper。 12345678910111213141516171819202122232425import timedef elapsed(f): def wrapper(*args, **kwargs): start = time.clock() ans = f(*args, **kwargs) print(&#x27;使用了&#123;:f&#125;秒&#x27;.format(time.clock() - start)) return ans return wrapper@elapseddef fib(n): prev, curr = 0, 1 for i in range(n-1): prev, curr = curr, prev + curr return prevprint(fib(100))# Output# 使用了0.000011秒# 218922995834555169026 下面的例子中介绍了装饰器如何存储信息。我们使用register装饰器来存储注册的函数。这个功能在一些python的web框架中有使用，被用来注册views，这样控制器在接到request时就知道去哪里找对应的响应函数。注：装饰器会在模块加载的时候执行 1234567891011121314151617181920212223242526272829def register(f): dictionary = &#123;&#125; dictionary[f.__name__] = f print(&#x27;已经注册的函数：&#123;&#125;&#x27;.format(dictionary)) def wrapper(*args, **kwargs): f(*args, **kwargs) return wrapper@registerdef func1(): pass@registerdef func2(): pass@registerdef func3(): pass# Output# 已经注册的函数：&#123;&#x27;func1&#x27;: &lt;function func1 at 0x000002A81F633840&gt;&#125;# 已经注册的函数：&#123;&#x27;func2&#x27;: &lt;function func2 at 0x000002A81F633950&gt;&#125;# 已经注册的函数：&#123;&#x27;func3&#x27;: &lt;function func3 at 0x000002A81F633A60&gt;&#125; 迭代器与生成器 Wiki 迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。 迭代器的概念来源于设计模式。在python中，迭代器实现了__iter__和__next__方法。注：Iterable和Iterator的区别：Iterable实现了__iter__方法/接口（返回一个Iterator），而Iterator实现了__iter__（Iterator本身也是Iterable）和__next__方法/接口。 由于迭代器实现了__next__方法，就可以通过next(iterator)来获取下一个元素，直到没有下一个元素时，抛出StopIteration异常。 12345678s = range(10)s = iter(s) # 返回迭代器print(next(s)) # 打印出下一个元素print(next(s))# Output# 0# 1 迭代器在python中使用很多，比如我们对range list tuple dict set使用for .. in ..的时候，会自动调用iter函数返回一个迭代器，并且这个语句会自动处理StopIteration异常。python标准库itertools中有很多有用的与迭代器有关的工具。 12345678s = range(3)for e in s: print(e)# Output# 0# 1# 2 生成器（generator）是一种特殊的迭代器。像我们之前使用的range就是一个生成器。python中使用yield关键词而不是return来定义一个生成器。 123456789101112131415def generator(): n = 0 while True: yield n n += 1gen = generator()for _ in range(3): print(next(gen))# Output# 0# 1# 2 从上述例子中，我们可以看出生成器是惰性求值的实现，如果我们希望遍历一个很大的列表，但是又不希望存储这么多的元素，我们就可以使用生成器。比如上述例子是用来产生一个无穷的计数器，显然我们不可能存储无穷多个数字，我们可以使用生成器，这样每次只产生一个数字，当然这样的话就只能按顺序获取元素，而不能随机访问。 除了使用yield关键词外，另一种定义生成器的方法类似于列表推导，但是将[]替换为()了。 123456789101112131415gen = (i for i in range(3))print(next(gen))print(next(gen))print(next(gen))print(next(gen)) # 会抛出StopIteration异常，因为没有元素了# Output# 0# 1# 2# Traceback (most recent call last):# File &quot;c:/Users/Zaki/Desktop/test3.py&quot;, line 6, in &lt;module&gt;# print(next(gen))# StopIteration 还可以通过yield from关键词来从别的生成器产生新的生成器。比如下面的例子中合并了两个生成器为一个生成器。 12345678910111213141516171819202122232425def fib(n): prev, curr = 0, 1 for _ in range(n): yield curr prev, curr = curr, prev + currdef new_generator(): yield from range(3) print(&#x27;fib&#x27;) yield from fib(3)gen = new_generator()for e in gen: print(e)# Output# 0# 1# 2# fib# 1# 1# 2 协程 协程（Coroutine）是一种程序组件，类似于子程序。可以用来处理并发。python中同样是使用yield关键词来产生协程，但是这两个是不同的东西！，并且协程的yield在=的右边。协程在执行到yield时会暂停，直到通过send发送一个数据给协程来继续。 123456789101112131415def coroutine(): while True: print(&#x27;准备接收x&#x27;) x = yield print(&#x27;接收到 x=&#123;&#125;&#x27;.format(x))co = coroutine()next(co) # 需要使用next()或者co.send(None)来激活协程co.send(&#x27;1&#x27;)# Output# 准备接收x# 接收到 x=1# 准备接收x 还可以通过yield from关键词来从一个子协程中产生协程，并且此时会自动激活子协程。这种方式可以想象成这个协程建立了调用方和子协程之间的通道。 12345678910111213141516171819202122232425def sub_coroutine(): while True: print(&#x27;子协程等待 x&#x27;) x = yield print(&#x27;接收到 x=&#123;&#125;&#x27;.format(x))def coroutine(): while True: print(&#x27;协程准备&#x27;) yield from sub_coroutine()co = coroutine()next(co) # 这个协程还是需要激活的co.send(&#x27;1&#x27;)co.send(&#x27;2&#x27;)# Output# 协程准备# 子协程等待 x# 接收到 x=1# 子协程等待 x# 接收到 x=2# 子协程等待 x 上下文管理 在python中，上下文管理非常常见，比如with语句。当我们使用with语句时，就构建了一个上下文环境，在这个环境中，我们可以做一些事情，比如操作IO，当我们退出了这个环境时，上下文管理器可以帮我们自动进行一些事后处理，比如关闭IO。 下面的例子中，我们使用@contextlib.contextmanager装饰器来装饰my_open函数，让这个函数成为了上下文管理器，它会帮我们在操作文件完成后自动关闭文件，效果和with open() as f相似，不过没有很好处理异常。 12345678910111213141516171819202122import contextlib@contextlib.contextmanagerdef my_open(*args): f_handler = open(*args) msg = &#x27;&#x27; try: yield f_handler except Exception as err: msg = err.msg() finally: f_handler.close() if msg: print(msg)with my_open(&#x27;D:\\\\1.txt&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;123&#x27;)# Output# 会创建文件&#x27;D:\\\\1.txt&#x27;并写入&#x27;123&#x27;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python的itertools工具包中的生成器","slug":"python的itertools工具包中的生成器","date":"2018-01-13T07:48:32.000Z","updated":"2020-08-23T11:25:39.163Z","comments":true,"path":"2018/01/13/python的itertools工具包中的生成器/","link":"","permalink":"http://yoursite.com/2018/01/13/python%E7%9A%84itertools%E5%B7%A5%E5%85%B7%E5%8C%85%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"Python标准库中Itertools工具包中的生成器","text":"Python标准库中Itertools工具包中的生成器 1 用于扩展输出的生成器函数 count(start=0, step=1) 说明：从start开始不断产出数字，步长为step 12345678910111213# 产生3以后的数字，步长为3import itertoolsgen = itertools.count(3, 3)for i in range(5): print(next(gen))# Output:# 3# 6# 9# 12# 15 cycle(it) 说明：循环产出it中的元素 1234567891011121314151617181920# 时钟生成import itertoolshours = range(1, 13)gen = itertools.cycle(hours)for i in range(24): print(next(gen))# Output:# 1# 2# ...# 11# 12# 1# 2# ...# 11# 12 repeat(item, [times]) 说明：不断重复产生item，除非提供了times参数 1234567891011# 不断产生helloimport itertoolsgen = itertools.repeat(&#x27;hello&#x27;, 3)for elem in gen: print(elem)# Output:# hello# hello# hello combinations(it, out_len) 说明：这是一种组合学生成器，可以用来生成it中out_len个元素的组合 12345678910111213141516# 产生列表a中的任意两个元素的不重复选取的组合，取出不放回的问题import itertoolsa = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]gen = itertools.combinations(a, 2)for elem in gen: print(elem)# Output:# (&#x27;a&#x27;, &#x27;b&#x27;)# (&#x27;a&#x27;, &#x27;c&#x27;)# (&#x27;a&#x27;, &#x27;d&#x27;)# (&#x27;b&#x27;, &#x27;c&#x27;)# (&#x27;b&#x27;, &#x27;d&#x27;)# (&#x27;c&#x27;, &#x27;d&#x27;) combinations_with_replacement(it, out_len) 说明：与combinations相似，不过其中的元素可以重复 12345678910111213141516# 产生列表a中的任意两个元素的可以重复选取的组合，取出并放回的问题import itertoolsa = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]gen = itertools.combinations_with_replacement(a, 2)for elem in gen: print(elem)# Output:# (&#x27;a&#x27;, &#x27;a&#x27;)# (&#x27;a&#x27;, &#x27;b&#x27;)# (&#x27;a&#x27;, &#x27;c&#x27;)# (&#x27;b&#x27;, &#x27;b&#x27;)# (&#x27;b&#x27;, &#x27;c&#x27;)# (&#x27;c&#x27;, &#x27;c&#x27;) permutations(it, out_len=None) 说明：这是一种组合学生成器，可以用来生成it中out_len个元素的排列 12345678910111213141516# 产生列表a中的任意两个元素的排列import itertoolsa = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]gen = itertools.permutations(a)for elem in gen: print(elem)# Output:# (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)# (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;)# (&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;)# (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;)# (&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;)# (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) 2 用于过滤的生成器函数 compress(it, selector_it) 说明：并行地处理两个iterator，如果selector_it中的元素为真，产出it中对应位置的元素 1234567891011121314# 选择出字符串a中对应位置的字符import itertoolsa = &#x27;example&#x27;b = (1, 0, 0, 1, 0, 0, 1)gen = itertools.compress(a, b)for elem in gen: print(elem)# Output:# e# m# e takewhile(pred, it) 说明：从it中产出元素直到pred为假时停止 1234567891011121314# 从列表a中选择出小于5的那些数字import itertoolsa = [1, 2, 3, 4, 5, 6, 7]gen = itertools.takewhile(lambda n: n &lt; 5, a)for elem in gen: print(elem)# Output:# 1# 2# 3# 4 dropwhile(pred, it) 说明：与takewhile相反，pred为假时开始从it中产出元素 12345678910111213# 从列表a中选择出大于等于5的那些数字import itertoolsa = [1, 2, 3, 4, 5, 6, 7]gen = itertools.dropwhile(lambda n: n &lt; 5, a)for elem in gen: print(elem)# Output:# 5# 6# 7 filterfalse(pred, it) 说明：与内置函数filter(pred, it)相反，将it从各个元素传给pred，如果返回为假，则产出这个元素 1234567891011121314# 从列表a中选择出不为偶数的那些数字import itertoolsa = [1, 2, 3, 4, 5, 6, 7]gen = itertools.filterfalse(lambda n: n % 2 == 0, a)for elem in gen: print(elem)# Output:# 1# 3# 5# 7 islice(it, stop)/islice(it, start, stop, step=1) 说明：产出it的切片，作用类似于s[:stop]或者s[start:stop:step]，不过it是任何可迭代对象，而且返回一个生成器 1234567891011121314151617181920212223242526272829303132# 从列表a中选择出特定位置的那些数字import itertoolsa = [1, 2, 3, 4, 5, 6, 7]gen = itertools.islice(a, 4)for elem in gen: print(elem)# Output:# 1# 2# 3# 4gen = itertools.islice(a, 2, 6)for elem in gen: print(elem)# Output:# 3# 4# 5# 6gen = itertools.islice(a, 2, 6, 2)for elem in gen: print(elem)# Output:# 3# 5 3 用于合并多个可迭代对象的生成器函数 chain(it1, it2, … itN) 说明：将it1到itN串行连接起来 12345678910111213141516171819# 将a和b合并为一个生成器import itertoolsa = range(0, 10, 2)b = range(1, 10, 2)gen = itertools.chain(a, b)for elem in gen: print(elem)# Output:# 0# 2# ...# 8# 1# 3# ...# 9 product(it1, it2, …, itN, repeat=1) 说明：计算笛卡尔积，从每个it中获取元素，合并成N个元素组成的元组，repeat指明重复处理多少次输入的可迭代对象 123456789101112131415# 计算a和b的笛卡尔积import itertoolsa = [0, 1]b = [2, 3]gen = itertools.product(a, b)for elem in gen: print(elem)# Output:# (0, 2)# (0, 3)# (1, 2)# (1, 3) zip_longest(it1, it2, … itN, fillvalue=None) 说明：并行地从各个it中获取元素，产出N个元素组成的元组，直到最长的it到头后才停止，空缺的值由fillvalue填充 12345678910111213import itertoolsa = [0, 1]b = [2, 3, 4]gen = itertools.zip_longest(a, b)for elem in gen: print(elem)# Output:# (0, 2)# (1, 3)# (None, 4) 4 用于映射的生成器函数 accumulate(it, [func]) 说明：产出it累计的总和，如果提供了func，那么会将前两个元素传给func，然后把计算结果和下一个元素传给func，以此类推 1234567891011121314151617181920212223242526272829import itertoolsa = [0, 1, 3, 7, 2, 5, 1]gen = itertools.accumulate(a)for elem in gen: print(elem)# Output:# 0# 1# 4# 11# 13# 18# 19gen = itertools.accumulate(a, max)for elem in gen: print(elem)# Output:# 0# 1# 3# 7# 7# 7# 7 5 用于重新排列元素的生成器 groupby(it, key=None) 说明：产出由两个元素组成的元素，形式为(key, group)，其中key为分组标准，group是生成器，用于产出分组里的元素 1234567891011121314151617# 根据列表中的单词的长度进行分组import itertoolsa = [ &#x27;rat&#x27;, &#x27;pig&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;eagle&#x27;, &#x27;giraffe&#x27;, &#x27;dolphin&#x27;, &#x27;elephant&#x27;, &#x27;bear&#x27;, &#x27;duck&#x27;]for length, group in itertools.groupby(a, len): print(length, &#x27;--&gt;&#x27;, list(group))# Output:# 3 --&gt; [&#x27;rat&#x27;, &#x27;pig&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;]# 5 --&gt; [&#x27;eagle&#x27;]# 7 --&gt; [&#x27;giraffe&#x27;, &#x27;dolphin&#x27;]# 8 --&gt; [&#x27;elephant&#x27;]# 4 --&gt; [&#x27;bear&#x27;, &#x27;duck&#x27;] tee(it, n=2) 说明：产出n个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素 1234567891011121314151617# 产生3个生成器aimport itertoolsa = range(1, 5, 2)gens = itertools.tee(a, 3)for gen in gens: for elem in gen: print(elem)# Output:# 1# 3# 1# 3# 1# 3","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"两种防御性编程手段","slug":"两种防御性编程手段","date":"2018-01-12T09:08:42.000Z","updated":"2020-08-23T10:40:44.280Z","comments":true,"path":"2018/01/12/两种防御性编程手段/","link":"","permalink":"http://yoursite.com/2018/01/12/%E4%B8%A4%E7%A7%8D%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B%E6%89%8B%E6%AE%B5/","excerpt":"两种防御性编程手段 LBYL: Look Before You Leap EAFP: It’s Easier to Ask Forgiveness than Permission 第一种手段也就是事先进行检查 第二种手段也就是不进行检查，出了异常再处理异常","text":"两种防御性编程手段 LBYL: Look Before You Leap EAFP: It’s Easier to Ask Forgiveness than Permission 第一种手段也就是事先进行检查 第二种手段也就是不进行检查，出了异常再处理异常 给出一个示例 1234567891011121314151617a = &#123;&#125;b = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]# LBYLfor c in b: if c not in a: a[c] = 1 else: a[c] += 1# EAFPfor c in b: try: a[c] += 1 except: a[c] = 1 EAFP可能会降低一些性能，但是在异常发生可能性比较低的时候影响不大 另外对于原子操作推荐使用EAFP的方式","categories":[{"name":"常用","slug":"常用","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"常用正则表达式","slug":"常用正则表达式","date":"2017-12-19T07:16:01.000Z","updated":"2020-08-23T10:40:44.281Z","comments":true,"path":"2017/12/19/常用正则表达式/","link":"","permalink":"http://yoursite.com/2017/12/19/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"常用正则表达式","text":"常用正则表达式 校验数字的表达式 12345678910111213141516171819数字：^[0-9]*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$非零的负整数：^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$非负整数：^\\d+$ 或 ^[1-9]\\d*|0$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 校验字符的表达式 123456789101112汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;&#x27;,;=?$\\x22]+禁止输入含有~的字符：[^~\\x22]+ 特殊需求表达式 12345678910111213141516171819202122232425262728293031323334Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$钱的输入格式：有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$中文字符的正则表达式：[\\u4e00-\\u9fa5]双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) (由@飞龙三少 提供，感谢共享)","categories":[{"name":"常用","slug":"常用","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2017-12-06T13:33:28.000Z","updated":"2020-08-23T11:25:59.187Z","comments":true,"path":"2017/12/06/markdown语法/","link":"","permalink":"http://yoursite.com/2017/12/06/markdown%E8%AF%AD%E6%B3%95/","excerpt":"Markdown基本语法","text":"Markdown基本语法 标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 列表 无序列表 123- item1- item2- item3 item1 item2 item3 有序列表 1231. item12. item23. item3 item1 item2 item3 复选框 12- [x] 任务1- [ ] 任务2 [x] 任务1 [ ] 任务2 链接 1[name](url) 例如[百度](http://www.baidu.com)显示如下 百度 图片 1![name](图片url) 例如![name](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)显示如下 引用 12&gt; 引用的文字&gt;&gt; 嵌套引用 引用的文字 嵌套引用 粗体和斜体 123**粗体***斜体*~~删除线~~ 粗体 斜体 删除线 水平线 12345* * *********- - ---------------------------------------- 代码引用 12使用一对1个`包裹起来来引用一行代码使用一对3个`包裹起来来引用多行代码，可以指定语言 一行代码 1多行代码 表格 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 流程图（可能需要插件） 1234567891011&#123;3个`&#125;flowst=&gt;start: 开始:&gt;http://www.google.com[blank]e=&gt;end: 结束:&gt;http://www.google.comop1=&gt;operation: 我的行动sub1=&gt;subroutine: 我的子程序cond=&gt;condition: 是或否?:&gt;http://www.google.comio=&gt;inputoutput: 抓住一些东西...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1&#123;3个`&#125; 序列（可能需要插件） 12345&#123;3个`&#125;sequenceAlice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!&#123;3个`&#125; 数学公式（可能需要插件） 行内 1单位圆公式 $x^2+y^2=1$ 单位圆公式 x2+y2=1x^2+y^2=1x2+y2=1 段落 123单位圆公式$$x^2+y^2=1$$ 单位圆公式 x2+y2=1x^2+y^2=1 x2+y2=1 st=>start: 开始:>http://www.google.com[blank] e=>end: 结束:>http://www.google.com op1=>operation: 我的行动 sub1=>subroutine: 我的子程序 cond=>condition: 是或否?:>http://www.google.com io=>inputoutput: 抓住一些东西... st->op1->cond cond(yes)->io->e cond(no)->sub1(right)->op1{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"git使用","slug":"git使用","date":"2017-12-06T12:15:46.000Z","updated":"2020-08-23T11:26:11.584Z","comments":true,"path":"2017/12/06/git使用/","link":"","permalink":"http://yoursite.com/2017/12/06/git%E4%BD%BF%E7%94%A8/","excerpt":"Git使用","text":"Git使用 一、 Git 命令初识 在正式介绍Git命令之前，先介绍一下Git 的基本命令和操作，对Git命令有一个总体的认识 从Git版本库的初始化，通常有两种方式： git clone 这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份。 例如： 1git clone git://github.com/someone/some_project.git some_project 上面的命令就是将git://github.com/someone/some_project.git这个URL地址的远程版本库，完全克隆到本地some_project目录下 git init 和 git remote 这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用git init命令进行初始化。Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用git remote add命令来增加一个远程服务器端。 例如： 1git remote add origin git://github.com/someone/another_project.git 上面的命令就会增加URL地址为git://github.com/someone/another_project.git，名称为origin的远程服务器，以后提交代码的时候只需要使用origin别名即可 二、 Git 常用命令 远程仓库相关命令 检出仓库 1git clone git://github.com/jquery/jquery.git 查看远程仓库 1git remote -v 添加远程仓库 1git remote add [name] [url] 删除远程仓库 1git remote rm [name] 修改远程仓库 1git remote set-url --push [name] [newUrl] 拉取远程仓库 1git pull [remoteName] [localBranchName] 推送远程仓库 1git push [remoteName] [localBranchName] 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下： 12git push origin test:master # 提交本地test分支作为远程的master分支git push origin test:test # 提交本地test分支作为远程的test分支 分支(branch)操作相关命令 查看本地分支 1git branch 查看远程分支 1git branch -r 创建本地分支 1git branch [name] # 注意新分支创建后不会自动切换为当前分支 切换分支 1git checkout [name] 创建新分支并立即切换到新分支 1git checkout -b [name] 删除分支 12git branch -d [name] # -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。 # 如果想强制删除一个分支，可以使用-D选项 合并分支 1git merge [name] # 将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程) 1git push origin [name] 删除远程分支 123git push origin:heads/[name]# 或git push origin :[name] 创建空的分支(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔) 123git symbolic-ref HEAD refs/heads/[name]rm .git/indexgit clean -fdx 版本(tag)操作相关命令 查看版本 1git tag 创建版本 1git tag [name] 删除版本 1git tag -d [name] 查看远程版本 1git tag -r 创建远程版本(本地版本push到远程) 1git push origin [name] 删除远程版本 1git push origin:refs/tags/[name] 合并远程仓库的tag到本地 1git pull origin --tags 上传本地tag到远程仓库 1git push origin --tags 创建带注释的tag 1git tag -a [name] -m &#x27;your message&#x27; 子模块(submodule)相关操作命令 添加子模块 1git submodule add [url] [path] 例如’$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs’ 初始化子模块 1git submodule init # 只在首次检出仓库时运行一次就行 更新子模块 1git submodule update # 每次更新或切换分支后都需要运行一下 删除子模块：（分4步走哦） git rm --cached [path] 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 手动删除子模块残留的目录 忽略一些文件、文件夹不提交 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如 123targetbin*.db","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"常用","slug":"常用","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}